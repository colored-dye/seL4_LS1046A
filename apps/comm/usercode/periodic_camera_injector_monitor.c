/* This file has been autogenerated by Ivory
 * Compiler version  0.1.0.3
 */
#include "periodic_camera_injector_monitor.h"

struct camera_data camera_data_st;

struct camera_data camera_data_prev;

uint32_t camera_data_watch = (uint32_t) 0U;

void callback_camera_req(const uint32_t *n_var0)
{
    uint16_t n_deref0 = camera_data_st.bbox_l;
    uint16_t n_deref1 = camera_data_st.bbox_r;
    uint16_t n_deref2 = camera_data_st.bbox_t;
    uint16_t n_deref3 = camera_data_st.bbox_b;
    uint16_t n_deref4 = camera_data_prev.bbox_l;
    uint16_t n_deref5 = camera_data_prev.bbox_r;
    uint16_t n_deref6 = camera_data_prev.bbox_t;
    uint16_t n_deref7 = camera_data_prev.bbox_b;
    
    /* bbox inside bounds and invariants hold on l,r & t,b */
    /* at least one element is nonzero */
    /* at least one bound has changed */
    if ((bool) ((bool) (n_deref0 != n_deref4) || (bool) ((bool) (n_deref1 != n_deref5) || (bool) ((bool) (n_deref2 != n_deref6) || (bool) (n_deref3 != n_deref7))))) {
        uint32_t n_deref8 = camera_data_watch;
        
        camera_data_watch = (uint32_t) 0U;
    } else {
        uint32_t n_deref9 = camera_data_watch;
        
        camera_data_watch = (uint32_t) (n_deref9 + (uint32_t) 1U);
    }
    
    uint32_t n_deref10 = *n_var0;
    struct sequence_numbered_camera_target n_local11 = {};
    struct sequence_numbered_camera_target *n_ref12 = &n_local11;
    
    n_ref12->seqnum = n_deref10;
    
    uint32_t n_deref13 = camera_data_watch;
    
    /* Valid packet: valid bounds, at least one nonzero element, and no more at 10 requests without a corner changing. */
    /* Yes, I know the 2nd property could be make to be a consequence of the 3rd. */
    ;
    
    struct camera_target *n_cse17 = &n_ref12->val;
    
    n_cse17->valid = (bool) ((bool) ((bool) ((bool) ((bool) (0 != n_deref0) || (bool) (0 != n_deref1)) || (bool) (0 != n_deref2)) || (bool) (0 != n_deref3)) && (bool) ((bool) ((bool) (n_deref1 <= (uint16_t) 320U) && (bool) ((bool) (n_deref0 < n_deref1) && (bool) ((bool) (n_deref3 <= (uint16_t) 200U) && (bool) (n_deref2 < n_deref3)))) && (bool) (n_deref13 < (uint32_t) 10U)));
    n_cse17->bbox_l = n_deref0;
    n_cse17->bbox_r = n_deref1;
    n_cse17->bbox_t = n_deref2;
    n_cse17->bbox_b = n_deref3;
    camera_data_prev = camera_data_st;
    callback_cameraTargetInputGetRespProducer(n_ref12);
}

void callback_cameraDataRx(const struct camera_data *n_var0)
{
    camera_data_st = *n_var0;
}